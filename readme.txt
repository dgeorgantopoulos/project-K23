ΑΛΕΞΑΝΔΡΟΣ ΘΕΜΕΛΗΣ sdi1900062
ΔΗΜΗΤΡΙΟΣ ΓΕΩΡΓΑΝΤΟΠΟΥΛΟΣ sdi1900036
Υλοποίηση 1ης προγραμματιστικής εργασίας πολυγωνοποίησης σημειοσυνόλων

ΣΗΜΑΝΤΙΚΟ:
Εξαιτίας της διαφοράς δυσκολίας μεταξύ των δύο αλγορίθμων, αποφασίσαμε οι εργασίες να γίνουν με την ταυτόχρονη συνεργασία και των δυο μας σε έναν υπολογιστή, εξού και τα commit μόνο από ένα account. Και οι δύο μας έχουμε πλήρη γνώση όλων των σημείων του προγράμματος και μπορούμε να εξηγήσουμε την εκτέλεσή του λεπτομερώς.

για την μεταγλώττιση του προγράμματος στα linux της σχολής, όντας στο directory, καλούμε τις εντολές “cmake -DCGAL_DIR=usr/include/CGAL .” και ύστερα “make”. Έτσι, μπορεί πλέον να εκτελεστεί μέσω της υποδεδειγμένης εντολής της εκφώνησης.

ΣΗΜΑΝΤΙΚΗ ΣΗΜΕΙΩΣΗ: Στον αυξητικό αλγόριθμο στην επιλογή ακμών προσθήκης μεγίστου και ελαχίστου εμβαδού, παρ’όλο που η εκτέλεση παρουσίαζε καθυστέρηση, αυτή ολοκληρωνόταν με επιτυχία για κάθε αρχείο σημειοσυνόλων που δοκιμάστηκε.

Λίστα αρχείων:
CMakeLists.txt (έχει επεξεργαστεί καταλλήλως για separate compilation)
to_polygon.cpp (η main συνάρτηση, που διαβάζει, κάνει χρονομετρήσεις και βγάζει αποτελέσματα)
includes/CMakeLists.txt (έχει επεξεργαστεί καταλλήλως για separate compilation)
includes/convex_hull_alg.cpp (αλγόριθμος βάσει ΚΠ)
includes/functions.cpp (βοηθητικές συναρτήσεις για διάβασμα σημείων και area από input files,και sort)
includes/functions.h
includes/incremental_alg.cpp (αυξητικός αλγόριθμος)
dokimes.txt (αρχείο δοκιμών με διάφορα αρχεία, με τα αντίστοιχα ratio και ενδεικτικούς χρόνους)
readme.txt

ΣΧΟΛΙΑΣΜΟΣ ΑΠΟΤΕΛΕΣΜΑΤΩΝ:
Όσο αυξάνεται το μέγεθος των σημειοσυνόλων, τόσο προφανώς αυξάνεται και ο χρόνος του εκτέλεσης του προγράμματος ανεξαρτήτου αλγορίθμου, είδος σημειοσυνόλου, και κριτήριο επιλογής ακμής με ιδιαίτερη επιβάρυνση όμως στον αλγόριθμο βάσει ΚΠ. Η ακρίβεια του ratio με την αύξηση του μεγέθους των σημειοσυνόλων, παρουσιάζει εξαιρετική επιδείνωση, Όσον αφορά το είδος των σημειοσυνόλων, δεν παρατηρείται μεγάλη αυξομείωση στον χρόνο εκτέλεσης, αλλά και στο ratio συγκριτικά μεταξύ των ειδών(όμοια,τυχαία και εικόνα). Οσον αφορά την επιλογή ακμής,
 στο αλγόριθμο ΚΠ, η επιλογή προσθήκης προσθήκης minimum εμβαδού προσδίδει το χειρότερο ratio, ενώ η random και max παρουσιάζουν ουσιαστικά παρόμοια συμπεριφορά, ενώ σε σχέση με τον χρόνο υπερτερεί σε αποτελεσματικότητα κατά μεγάλο ποσοστό το random. Στον incremental αλγόριθμο, παρουσιάζεται καλύτερη απόδοση για κάθε σημειοσύνολο κατά την επιλογή ακμής με βάση την προσθήκη μεγίστου εμβαδού, ενώ το ελάχιστο εμβαδό παρουσιάζει χειρότερη απόδοση.

readPoints
Όσον αφορά το “διάβασμα” σημείων απο τα αρχεία εισόδου, διαβάζουμε τα συγκεκριμένα αρχεία γραμμή-γραμμή, μέσω της συνάσρτησης getline. Την κάθε γραμμή πια την μετατρέπουμε σε μορφή char* έτσι ώστε να μπορέσουμε να την επεξεργαστούμε περαιτέρω. Ταυτόχρονα, διατηρούμε μια μεταβλητή count, η οποία αξιοποιείται για την αποφυγή των πρώτων δυο γραμμών, αφού έμεις θέλουμε για την ΄ώρα να επεξεργαστούμε μόνο τα σημεία. Γνωρίζουμε οτι τα κάθε στήλη είναι tab-separated. Γι’αυτό μέσω της τριπλής κλήσης της strtok(με όρισμα “\t” δηλαδή tab), λαμβάνουμε την αντίστοιχη πρωτη δευτερη και τρίτη στήλη του αντίστοιχου line στο οποίο βρισκόμαστε. Μετατρέπουμε τα επιθυμητά στοιχεία σε integer μέσω της atoi, και τα αποθηκεύουμε σε ενα vector p, ο οποίος έχει μέσα του όλα μας τα σημεία τύπου Point_2, και τον κάνουμε return.

ΑΛΓΟΡΙΘΜΟΣ ΜΕ ΒΑΣΗ ΤΟ ΚΠ


Για κάθε ενα από τα σημεία τα οποία έχουμε διαβάσει στο αρχείο, τα βάζουμε σε vector ονόματι convexHull (τύπου point_2), έτσι ώστε αρχικά να φτιάξουμε το κυρτό περίβλημα όλων των σημείων. Αυτό γίνεται μέσω της συνάρτησης convex_hull_2, μέσω της οποίας έχουμε την αρχική μορφή του ΚΠ στη vector result, αλλά και στην PolygonChain, εφόοσν τα δυο αυτά ταυτίζονται για όλα τα σημεία. Μένει πλέον να ανιχνεύσουμε τα σημεία τα οποία δεν ανήκουν στο ΚΠ αλλά βρίσκονται μέσα αυτού(interiorPoints). Αυτά ουσιαστικά αποτελούν τα σημεία του vect (όπου βρίσκονται όλα τα σημεία που διαβάσαμε από το αρχείο), τα οποία δεν ανήκουν στο ΚΠ (δηλαδή στο result). Tα βρίσκουμε μέσα της find, και τα pushάρουμε στον vector με τα εσωτερικά σημεία.
Μέσω της μεταβλητής flag_visible, θα επιλέγεται το κριτήριο για την επιλογή ορατής ακμής(περιπτώσεις 1,2,3).
Όσο υπάρχουν ακόμη εσωτερικά σημεία, στην περίπτωση της τυχαίας επιλογής ορατής ακμής, για κάθε μια από τις ακμές της πολυγωνικής αλυσίδας, θέλουμε να τραβήξουμε ακμές από κάθε vertex του ΚΠ, προς κάθε εσωτερικό σημείο. Μέσα σε ενα polygonChainCopy (τύπου polygon_2), προσθέτουμε την συγκεκριμένη ακμή, και ελέγχουμε μέσω της is_simple, για αν το πολύγωνο παραμένει απλό. Αν αυτό παραμένει απλό, τότε μπορεί να είναι “υποψήφιο” πολύγωνο, αν όχι, θέτουμε false το bool visibility(εξηγείται μετά ο λόγος). Κάνουμε break, και μέσω της erase αφού ανιχνεύσουμε το vertex που βάλαμε πορηγουμένως στο πολύγωνο, το αφαιρούμε ώστε να έρθει στην προηγούμενή του κατάσταση. Σε περίπτωση που το πολύγωνο με την προσθήκη του vertex ΔΕΝ ήταν απλό, συνεχίζουμε στοτ επόμενο εσωτερικό σημείο. Σε αντίθετη περίπτωση, αρχικά υπολογίζουμε την απόσταση του προκειμενου εσωτερικου σημείου από την ακμή μας, κρατώντας παράλληλα μεταβλητές min_distance, min_ch_edge,min_point για την αποθήκευση της μικρότερης δυνατής απόστασης ενός στοιχείου του συνόλου των εσωτερικών σημείων απο την τωρινή ακμή μας, την ακμή την ίδια, και το εσωτερικό σημείο που μας αφορά αντιστοίχως. Σε περίπτωση που βρήκαμε σημείο πιο κοντά στην ακμή απο προηγουμένως, το προσθέτουμε στο πολύγωνο, το αφαιρούμε, ελέγχουμε για την απλότητα του πολυγώνου κ.ο.κ. με την ίδια λογική που περιγράφηκε παραπάνω. Πλέον έχοντας την ακμή για την οποία της έχουμε βρεί το κοντινότερο σημείο, της τοποθετούμε μέσω της insert το κατάλληλο εσωτερικό σημείο, ενώ το διαγράφουμε απο το vector με τη λίστα των εσωτερικών σημείων. Καθώς σε κάθε περίσταση έχουμε πάρει το σημείο που βρίσκεται πιο κοντά στην ακμή, είναι αδύνατο με τη προσθήκη του στο πολύγωνο άλλα σημεία να γίνονται ξαφνικά εξωτερικά.
	Στην περίπτωση της επιλογής ορατής ακμής με στόχο τη πρόσθεση τη λιγότερου δυνατού εμβαδού, ακουλοθούμε την ίδια λογική με παραπάνω, με τη μόνη διαφορά οτι διατηρούμε μια δομή ονόματι minTotal, η οποία θα διατηρεί την απόσταση της τωρινής ακμής από το επιθυμητό εσωτερικό σημείο, την συγκεκριμένη ακμή, το σημείο, αλλά και το εμβαδόν που καταλαμβάνει το πολύγωνο σε περίπτωση προσθήκης του σημείου σε αυτό. Σε ενα vector tot, έχουμε πλέον αποθηκεύσει όλα τα δυνατά εμβαδά που προκύπτουν από την προσθήκη μεταξύ των vertex της ακμής μας, όλων των interior points. Προφανώς, διαλέγουμε το μικρότερο δυνατό, εν τέλει προσθέτωντας το κατάλληλο σημείο στο πολύγωνο polygonChain, και αφαιρούμε το σημείο από το vector των interiorPoints.
	Στην περίπτωση της επιλογής ορατής ακμής με στόχο τη πρόσθεση τη μεγαλύτερου δυνατού εμβαδού, ακολουθούμε σχέδον αποκλειστικά την ίδια φιλοσοφία με παραπάνω, με μόναδική διαφορά ότι όσο διατρέχουμε το tot, θα διαλέγουμε το εσωτερικό σημείο το οποίο προσδίδει το μεγαλύτερο min_area.

ΑΥΞΗΤΙΚΟΣ ΑΛΓΟΡΙΘΜΟΣ
Όσον αφορά την ταξινόμηση των στοιχείων, με τη κλήση της sort για τον vector γίνεται η αντίστοιχη ταξινόμηση με βάσει x σε αύξουσα σειρά. Για τις υπόλοιπες ταξινομήσεις, απαιτείται η χρήση επιπλέον “παραμέτρων”, και συγκεκριμένα bool, μέσω των οποίων γίνεται σύγκριση μεταξύ των στοιχείων τύπου Point_2 βάσει του x ή y τους αντιστοίχως.
Αρχικά, επιλέγουμε τα τρία “τελευταία” στοιχεία, με στόχο την δημιουργία του αρχικού τριγώνου στο οποίο λόγω της μορφής του, ταυτίζονται ΚΠ και πολυγωνική αλυσίδα (τα στοιχεία προστίθενται σε αυτά μέσω της προσθήκης μόνο 3 στοιχείων από το τέλος με τη χρήση της reverse begin στο κατάλληλο iterator. Για κάθε ένα από τα υπόλοιπα διατεταγμένα σημείο, αρχικά το προσθέτουμε στη δομή newConvexHull, βρίσκοντας το αντίστοιχο ΚΠ με την ύπαρξη του νέου σημείου. Στα vectors που αποθηκεύουν ακμές (segment_2) seg1 και seg2, θα αποθηκεύονται οι ακμές του ΚΠ πριν και μετά τη προσθήκη του νέου σημείου. Η αποθήκευση αυτών είναι σημαντική, εφόσον οι “κόκκινες” ακμές ενός πολυγώνου βρίσκονται μέσω της διαφοράς των συγκεκριμένων vectors. (καθώς το seg1 είναι το “¨παλιο” ΚΠ,γιαυτό και βρίσκεται στο “εξωτερικό” for loop, θα γίνεται η επιλογή των επιθυμητών red edges, δηλαδή αυτών που όντως ανήκουν στο προηγούμενο ΚΠ. Στη συνέχεια για κάθε red edge, που βρήκαμε, απαιτείται ο έλεγχος αν αυτή ανήκει ή όχι στη πολυγωνική αλυσίδα (trivial και non-trivial περίπτωση αντιστοίχως). Στην περίπτωση trivial, προφανώς δεν απαιτείται έλεγχος για την ορατότητα των ακμών που δημιουργούνται, εφόσον ήδη ανήκουν στην πολυγωνική αλυσίδα. Απλώς διατρέχουμε κάθε vertex της πολυγωνικής αλυσίδας, και προσθέτουμε ακριβώς “μπροστά” από το πρώτο άκρο της ακμής που θέλουμε να σπάσουμε (της red edge δηλαδή) το επιθυμητό σημείο, δημιουργώντας μέσω της insert το κατάλληλο πολύγωνο. Σε περίπτωση που δεν είναι trivial, τότε θα πρέπει να ψάξω τις “υποαλυσίδες” “πίσω” από την επιλεχθείσα κόκκινη ακμή μας. Αυτό γίνεται αρχικά κρατώντας τα άκρα της κόκκινης ακμής, και προσθέτωνας “μπροστά” σε κάθε vertex του πολυγώνου το επιθυμητό σημείο, δημιουργώντας κάθε πιθανή ακμή. Σε περίπτωση που οι δυο νέες ακμές που δημιουργούνται είναι οι “κόκκινες”, αυτό είναι κάτι το οποίο δεν θέλουμε, άρα συνεχίζουμε στο επόμενο vertex. Σε περίπτωση που η ακμή που θέλουμε να σπάσουμε ΔΕΝ είναι ορατή από το σημείο, τότε την διαγράφουμε και πάμε στο επόμενο vertex. Εάν είναι όμως, έχουμε βρει επιτυχώς τη νέα μας ακμή.
Όσον αφορά την επιλογή ακμών βάσει προσθήκης του ελαχίστου εμβαδού, δοκιμάζουμε όλα τα red edges, και όλους τους πιθανούς συνδυασμούς πολυγωνικών γραμμών με το σημείο που επίκεινται να προστεθεί. Για κάθε εναν από αυτούς διατηρούμε το συνολικό εμβαδόν, και επιλέγουμε τον συνδυασμό που έχει το μικρότερο, και ταυτοχρόνως καθιστά απλό το πολύγωνο.(Όμοια υλοποίηση και για τη προσθήκη μεγίστου εμβαδού). 